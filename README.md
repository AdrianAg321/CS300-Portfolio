CS 300 Final Portfolio Submission: Data Structures and Algorithms

What Was the Problem?

In this course, I focused on designing and analyzing data structures to manage and retrieve data efficiently. Project One required evaluating various structures'
run-time and memory usage, helping to understand how performance impacts system design. In Project Two, I developed a course planner that utilized a binary 
search tree to sort and display Computer Science courses in alphanumeric order.

How I Approached the Problem:

To address these problems, I began by evaluating the efficiency and scalability of different data structures. Understanding time and space complexity was key to 
selecting the most appropriate structures. For example, I used vectors to store dynamic lists and binary search trees for their ability to perform fast 
insertions, lookups, and in-order traversals. I also applied Big-O analysis to assess the trade-offs between different approaches and guide my design decisions.

Overcoming Roadblocks:

One of the most challenging aspects was implementing recursive functions for the binary search tree, particularly for insertion and printing operations. Early 
attempts led to logic errors and even stack overflow issues. I overcame these by isolating the logic into smaller, testable functions and leveraging debugging 
tools to complete each process. Additionally, I referred to C++ documentation to deepen my understanding of memory handling, recursion, and pointer manipulation, 
which ultimately helped me stabilize and optimize the code.

Evolving My Software Design Approach:

Through these projects, I developed a more strategic approach to software design. I began incorporating algorithmic thinking early in the problem-solving process 
and used visual aids like flowcharts and pseudocode to clarify my logic before implementation. This helped prevent errors and led to more structured, 
maintainable solutions. I also became more intentional about selecting data structures based on specific use cases rather than defaulting to familiar tools.

Writing More Maintainable Code:

My programming practices have become more focused on maintainability and readability. I consistently try to write modular code by organizing logic into separate, 
reusable functions. I also use descriptive naming conventions, add meaningful comments, and ensure that each program component can be understood without 
excessive explanation. These habits are essential for collaboration, long-term maintenance, and scalability in real-world software development.
